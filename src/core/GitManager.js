import { simpleGit } from 'simple-git';
import fs from 'fs-extra';
import path from 'path';

/**
 * Git operations manager
 * Handles automatic commits, pushes, and repository management for token changes
 */
export class GitManager {
  constructor(options = {}) {
    this.options = options;
    this.git = simpleGit();
  }

  /**
   * Check if we're in a git repository
   */
  async isGitRepository() {
    try {
      await this.git.checkIsRepo();
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Get current git status
   */
  async getStatus() {
    try {
      const status = await this.git.status();
      return {
        hasChanges: !status.isClean(),
        staged: status.staged,
        modified: status.modified,
        created: status.created,
        deleted: status.deleted,
        isClean: status.isClean()
      };
    } catch (error) {
      throw new Error(`Failed to get git status: ${error.message}`);
    }
  }

  /**
   * Get current branch
   */
  async getCurrentBranch() {
    try {
      const status = await this.git.status();
      return status.current || 'main';
    } catch (error) {
      console.warn(`Failed to get current branch: ${error.message}`);
      return 'main';
    }
  }

  /**
   * Get git author information
   */
  async getAuthor() {
    try {
      const [name, email] = await Promise.all([
        this.git.getConfig('user.name'),
        this.git.getConfig('user.email')
      ]);
      
      return {
        name: name.value || 'Unknown',
        email: email.value || 'unknown@example.com'
      };
    } catch (error) {
      return {
        name: 'design-tokens-sync',
        email: 'noreply@design-tokens-sync.com'
      };
    }
  }

  /**
   * Get current commit hash
   */
  async getCurrentCommit() {
    try {
      const log = await this.git.log({ maxCount: 1 });
      return log.latest?.hash?.substring(0, 7) || 'unknown';
    } catch (error) {
      return 'unknown';
    }
  }

  /**
   * Check if files have relevant changes
   */
  async hasRelevantChanges(filesToCheck) {
    try {
      const status = await this.getStatus();
      
      // Check if any of our target files have changes
      const allChangedFiles = [
        ...status.modified,
        ...status.created,
        ...status.staged
      ];

      return filesToCheck.some(file => 
        allChangedFiles.some(changedFile => 
          changedFile.includes(path.basename(file))
        )
      );
    } catch (error) {
      console.warn(`Failed to check for relevant changes: ${error.message}`);
      return false;
    }
  }

  /**
   * Add files to git staging area
   */
  async addFiles(files) {
    const existingFiles = [];
    
    // Filter to only existing files
    for (const file of files) {
      if (await fs.pathExists(file)) {
        existingFiles.push(file);
      }
    }

    if (existingFiles.length === 0) {
      throw new Error('No files exist to add to git');
    }

    try {
      await this.git.add(existingFiles);
      console.log(`üìù Added ${existingFiles.length} files to git:`, existingFiles.map(f => path.basename(f)).join(', '));
      return existingFiles;
    } catch (error) {
      throw new Error(`Failed to add files to git: ${error.message}`);
    }
  }

  /**
   * Create a commit with the changes
   */
  async createCommit(addedFiles, config) {
    try {
      const author = await this.getAuthor();
      const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
      
      // Generate commit message
      let commitMessage = config.git.commitMessage;
      if (commitMessage.includes('{{timestamp}}')) {
        commitMessage = commitMessage.replace('{{timestamp}}', timestamp);
      }

      // Add file count and details
      const fileList = addedFiles.map(f => path.basename(f)).join(', ');
      const fullMessage = `${commitMessage}\n\nFiles updated: ${fileList}\nGenerated by design-tokens-sync`;

      // Create commit
      await this.git.commit(fullMessage, addedFiles, {
        '--author': `${author.name} <${author.email}>`
      });

      console.log(`‚úÖ Created commit: ${fullMessage.split('\n')[0]}`);
      return true;

    } catch (error) {
      throw new Error(`Failed to create commit: ${error.message}`);
    }
  }

  /**
   * Push changes to remote repository
   */
  async pushChanges(branch = null) {
    try {
      const currentBranch = branch || await this.getCurrentBranch();
      
      // Check if remote exists
      const remotes = await this.git.getRemotes(true);
      if (remotes.length === 0) {
        console.warn('‚ö†Ô∏è No git remotes configured - skipping push');
        return false;
      }

      console.log(`üöÄ Pushing changes to ${currentBranch}...`);
      
      await this.git.push('origin', currentBranch);
      console.log(`‚úÖ Successfully pushed changes to ${currentBranch}`);
      return true;

    } catch (error) {
      // Don't throw error for push failures - they're often not critical
      console.warn(`‚ö†Ô∏è Failed to push changes: ${error.message}`);
      return false;
    }
  }

  /**
   * Main commit workflow - adds files and creates commit
   */
  async commitChanges(config) {
    if (!config.git.enabled) {
      console.log('üì¥ Git operations disabled in configuration');
      return false;
    }

    // Check if we're in a git repository
    if (!await this.isGitRepository()) {
      console.warn('‚ö†Ô∏è Not in a git repository - skipping git operations');
      return false;
    }

    try {
      // Check if we have relevant changes
      const filesToAdd = config.git.filesToAdd || [
        config.tokens.input,
        config.output.css,
        config.output.tailwind
      ].filter(Boolean);

      const hasChanges = await this.hasRelevantChanges(filesToAdd);
      if (!hasChanges) {
        console.log('üìù No relevant changes detected - skipping commit');
        return false;
      }

      // Add files to staging
      const addedFiles = await this.addFiles(filesToAdd);
      
      // Create commit if auto-commit is enabled
      if (config.git.autoCommit) {
        await this.createCommit(addedFiles, config);
        
        // Push if auto-push is enabled
        if (config.git.autoPush) {
          await this.pushChanges();
        }
      }

      return true;

    } catch (error) {
      console.error('‚ùå Git operations failed:', error.message);
      
      // Don't throw error - git operations are supplementary
      // The main token sync should still succeed
      return false;
    }
  }

  /**
   * Get repository information
   */
  async getRepositoryInfo() {
    try {
      const [branch, author, commit, remotes] = await Promise.all([
        this.getCurrentBranch(),
        this.getAuthor(),
        this.getCurrentCommit(),
        this.git.getRemotes(true)
      ]);

      return {
        branch,
        author,
        commit,
        remotes: remotes.map(r => ({ name: r.name, url: r.refs.fetch })),
        isRepo: true
      };
    } catch (error) {
      return {
        branch: null,
        author: null,
        commit: null,
        remotes: [],
        isRepo: false,
        error: error.message
      };
    }
  }

  /**
   * Validate git environment
   */
  async validateEnvironment() {
    const validation = {
      isValid: true,
      issues: [],
      warnings: []
    };

    try {
      // Check if in git repo
      if (!await this.isGitRepository()) {
        validation.isValid = false;
        validation.issues.push('Not in a git repository');
        return validation;
      }

      // Check git configuration
      const author = await this.getAuthor();
      if (author.name === 'Unknown' || author.email === 'unknown@example.com') {
        validation.warnings.push('Git user name or email not configured');
      }

      // Check for remotes
      const remotes = await this.git.getRemotes();
      if (remotes.length === 0) {
        validation.warnings.push('No git remotes configured - push operations will fail');
      }

      // Check working directory status
      const status = await this.getStatus();
      if (status.hasChanges) {
        validation.warnings.push('Working directory has uncommitted changes');
      }

    } catch (error) {
      validation.isValid = false;
      validation.issues.push(`Git validation failed: ${error.message}`);
    }

    return validation;
  }

  /**
   * Initialize git repository if not exists
   */
  async initRepository() {
    try {
      if (await this.isGitRepository()) {
        console.log('üìÇ Already in a git repository');
        return true;
      }

      await this.git.init();
      console.log('üìÇ Initialized git repository');
      
      // Create initial .gitignore if it doesn't exist
      const gitignorePath = '.gitignore';
      if (!await fs.pathExists(gitignorePath)) {
        const gitignoreContent = `# Dependencies
node_modules/

# Build outputs
dist/
build/

# Environment files
.env*

# IDE files
.vscode/
.idea/

# OS files
.DS_Store
Thumbs.db

# Package cache
.tokens-sync-cache.json
`;
        await fs.writeFile(gitignorePath, gitignoreContent);
        console.log('üìù Created .gitignore file');
      }

      return true;
    } catch (error) {
      console.error('‚ùå Failed to initialize git repository:', error.message);
      return false;
    }
  }

  /**
   * Generate git hooks for automatic token syncing
   */
  async setupGitHooks() {
    try {
      const hooksDir = '.git/hooks';
      if (!await fs.pathExists(hooksDir)) {
        throw new Error('Git hooks directory not found');
      }

      // Pre-commit hook to validate tokens
      const preCommitHook = `#!/bin/sh
# Auto-generated by design-tokens-sync
# Validate tokens before commit

echo "üîç Validating design tokens..."
if npx design-tokens-sync validate; then
  echo "‚úÖ Design tokens validation passed"
else
  echo "‚ùå Design tokens validation failed"
  exit 1
fi
`;

      const preCommitPath = path.join(hooksDir, 'pre-commit');
      await fs.writeFile(preCommitPath, preCommitHook);
      await fs.chmod(preCommitPath, '755');

      console.log('ü™ù Set up git pre-commit hook for token validation');
      return true;

    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to set up git hooks:', error.message);
      return false;
    }
  }
} 